(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{385:function(t,e,a){"use strict";a.r(e);var r=a(27),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"框架通识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#框架通识"}},[t._v("#")]),t._v(" 框架通识")]),t._v(" "),a("h3",{attrs:{id:"mvvm-的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-的理解"}},[t._v("#")]),t._v(" MVVM 的理解")]),t._v(" "),a("h3",{attrs:{id:"数据劫持-proxy-和-object-defineproperty-对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据劫持-proxy-和-object-defineproperty-对比"}},[t._v("#")]),t._v(" 数据劫持，Proxy 和 "),a("code",[t._v("Object.defineProperty")]),t._v(" 对比")]),t._v(" "),a("h3",{attrs:{id:"virtual-dom-比-原生-dom-快么-列表中带-key-有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-比-原生-dom-快么-列表中带-key-有什么作用"}},[t._v("#")]),t._v(" Virtual Dom 比 原生 Dom 快么？ 列表中带 key 有什么作用？")]),t._v(" "),a("h2",{attrs:{id:"react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),a("h3",{attrs:{id:"react17-以前为什么必须要在顶部引入-react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react17-以前为什么必须要在顶部引入-react"}},[t._v("#")]),t._v(" React17 以前为什么必须要在顶部引入 React")]),t._v(" "),a("p",[t._v("React17 是如何解决的")]),t._v(" "),a("h3",{attrs:{id:"说说-redux-中-compose-的思路-或者说实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说-redux-中-compose-的思路-或者说实现"}},[t._v("#")]),t._v(" 说说 redux 中 compose 的思路，或者说实现")]),t._v(" "),a("h3",{attrs:{id:"为什么说-setstate-是异步的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么说-setstate-是异步的"}},[t._v("#")]),t._v(" 为什么说 setState 是异步的")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("react 组件之间有哪些通信方式")])]),t._v(" "),a("li",[a("p",[t._v("setState 什么时候同步什么时候异步")]),t._v(" "),a("ul",[a("li",[t._v("由 React 引发事件处理函数（合成事件、钩子函数等），会调用 bathedUpdated ，isBatchingUpdateds -> true 异步（数据最终merge）")]),t._v(" "),a("li",[t._v("默认 false ，同步，在 setTimeout 、原生事件中")])])]),t._v(" "),a("li",[a("p",[t._v("React 事件处理和原生的事件处理有什么区别")]),t._v(" "),a("ul",[a("li",[t._v("React 并不是直接把事件绑定在元素上，而是在 document 上监听，当事件冒泡到 document 上，react 会把事件封装并交给处理函数处理。")]),t._v(" "),a("li",[t._v("如果使用原生事件绑定，原生会先执行。")]),t._v(" "),a("li",[t._v("如果原生阻止冒泡，React 的就不会执行")])])]),t._v(" "),a("li",[a("p",[t._v("react hooks")]),t._v(" "),a("ul",[a("li",[t._v("useEffect 闭包陷阱。\n"),a("ul",[a("li",[t._v("函数式组件每次渲染都会重新执行，从而产生一个闭包环境")]),t._v(" "),a("li",[t._v("useEffect 重复调用了已经改变的 state ，但都是之前的值。（设置 依赖）")])])])])]),t._v(" "),a("li",[a("p",[t._v("Diff 算法")])])]),t._v(" "),a("p",[t._v("React 项目有哪些可以优化的点，实际项目中你是怎么处理的")]),t._v(" "),a("h2",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),a("h3",{attrs:{id:"双向绑定原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定原理是什么"}},[t._v("#")]),t._v(" 双向绑定原理是什么")])])}),[],!1,null,null,null);e.default=s.exports}}]);