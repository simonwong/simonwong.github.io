(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{417:function(e,t,r){"use strict";r.r(t);var a=r(27),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"react-fiber-架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber-架构"}},[e._v("#")]),e._v(" React Fiber 架构")]),e._v(" "),r("h2",{attrs:{id:"先看react-16以前的版本"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#先看react-16以前的版本"}},[e._v("#")]),e._v(" 先看"),r("code",[e._v("react@16")]),e._v("以前的版本")]),e._v(" "),r("blockquote",[r("p",[r("code",[e._v("reconciler")]),e._v("采用自顶向下递归，从根组件或"),r("code",[e._v("setState()")]),e._v("后的组件开始，更新他的整个子树")])]),e._v(" "),r("p",[e._v("浏览器正常的工作流程：运算 -> 渲染  -> 运算 -> 渲染 ...")]),e._v(" "),r("p",[e._v("缺点：")]),e._v(" "),r("ul",[r("li",[e._v("组件树越大，递归遍历成本越高，持续占用主线程 --\x3e 导致主线程上的布局、动画等周期性任务以及交互响应无法立即得到处理，造成卡顿")]),e._v(" "),r("li",[e._v("执行时间过长，导致fps降低")])]),e._v(" "),r("p",[r("img",{attrs:{src:"http://file.wangsijie.top/share/3.png",alt:""}})]),e._v(" "),r("p",[e._v("使用"),r("code",[e._v("fiber reconciler")]),e._v("(调解算法)将要执行的js做拆分，来保证不会阻塞主线程")]),e._v(" "),r("p",[r("img",{attrs:{src:"http://file.wangsijie.top/share/4.png",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"fiber-与-fiber-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber-与-fiber-tree"}},[e._v("#")]),e._v(" Fiber 与 Fiber tree")]),e._v(" "),r("p",[e._v("React@15 运行是存在3种实例")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("DOM\n\t真实DOM节点\n----\nInstances\n\t根据Elements创建。React维护的VDOM tree node。包含了组件状态、组件与DOM树的关系\n----\nElements\n\t描述UI长什么样子，type，props\n")])])]),r("p",[e._v("这个时候的调度叫做"),r("code",[e._v("Stack reconciler")]),e._v("。自顶向下递归"),r("code",[e._v("mount / update")]),e._v("。"),r("strong",[e._v("无法中断")])]),e._v(" "),r("p",[e._v("React@16 Filber架构运行时，将Instances层增加了实例")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("DOM\n\t真实DOM节点\n----------\neffect\n\t每个workInProgress tree节点上都有一个effect list。存放diff结果。节点更新完后向上merge\n- - - \nworkInProgress\n\tworkInProgress tree是调解过程中的进度快照，用于断点恢复，在这里收集effect list\n- - -\nfiber\n\tfiber tree类似vDOM tree\n----------\nElements\n\t描述UI长什么样子，type，props\n")])])]),r("h3",{attrs:{id:"react-15"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-15"}},[e._v("#")]),e._v(" React@15")]),e._v(" "),r("p",[r("code",[e._v("react@15")]),e._v("中，更新分为两个阶段：")]),e._v(" "),r("p",[e._v("1、diff：对比前后（遍历，比较，可拆分，算一半然后接着算，执行阶段主线程一直被占用）")]),e._v(" "),r("p",[e._v("2、patch：将diff后的差异队列更新到真实DOM上，是一连串的DOM操作")]),e._v(" "),r("p",[e._v("diff是一次性计算出所有差异，再一次性执行patch")]),e._v(" "),r("h3",{attrs:{id:"fiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[e._v("#")]),e._v(" Fiber")]),e._v(" "),r("p",[e._v("以一个fiber为单元进行拆分。fiber tree是根据VDOM tree构造出来的，然后在基础之上增加了一些属性")]),e._v(" "),r("blockquote",[r("p",[e._v("fiber指的是fiber tree上的节点。")]),e._v(" "),r("p",[e._v("Fiber表示 React Fiber")])]),e._v(" "),r("div",{staticClass:"language-javascript extra-class"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    alternate"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" Fiber"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 在fiber更新时克隆出的镜像fiber，对fiber的修改会标记在这个fiber上")]),e._v("\n    nextEffect"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" Fiber "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 单链表结构，方便遍历 Fiber Tree 上有副作用的节点")]),e._v("\n    pendingWorkPriority"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" PriorityLevel"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 标记子树上待更新任务的优先级")]),e._v("\n\n\tstateNode"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" any"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 管理 instance 自身的特性")]),e._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" Fiber"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 指向 Fiber Tree 中的父节点。处理完后，向谁提交自己的effect list")]),e._v("\n    child"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" Fiber"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 指向第一个子节点")]),e._v("\n    sibling"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" Fiber"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 指向兄弟节点")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),r("p",[r("img",{attrs:{src:"http://file.wangsijie.top/share/5.png",alt:""}})]),e._v(" "),r("p",[r("img",{attrs:{src:"http://file.wangsijie.top/share/7.png",alt:""}})]),e._v(" "),r("h3",{attrs:{id:"执行顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行顺序"}},[e._v("#")]),e._v(" 执行顺序")]),e._v(" "),r("p",[e._v("Stack 执行是以一整个tree为单位。且只能同步执行。")]),e._v(" "),r("p",[e._v("Fiber 是以一个fiber为单位执行。对fiber做调度处理。")]),e._v(" "),r("p",[e._v("比如说执行 A -> B -> C")]),e._v(" "),r("p",[e._v("Stack是依次执行，并不可中断")]),e._v(" "),r("p",[e._v("Fiber是，A -> B 发现有更重要的事情，中断，然后回来执行B -> C")]),e._v(" "),r("p",[e._v("时间切片：A-> B切片 B-> C切片。A -> B执行了一半，发现时间用完了，赶紧过去看看有没有紧急任务。发现有。马上去执行重要的任务，然后回来重新A -> B")]),e._v(" "),r("p",[r("img",{attrs:{src:"http://file.wangsijie.top/share/6.jpg",alt:" "}})]),e._v(" "),r("p",[e._v("两个阶段：")]),e._v(" "),r("ul",[r("li",[e._v("Reconciliation Phase，找出需要更新的DOM，可以打断")])]),e._v(" "),r("p",[e._v("包含了（componentWillMount、componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate）")]),e._v(" "),r("ul",[r("li",[e._v("Commit Phase，一次性把DOM更新完，绝不会被打断")])]),e._v(" "),r("p",[e._v("（componentDidMount、componentDidUpdate、componentWillUnmount）")]),e._v(" "),r("h3",{attrs:{id:"render-reconciliation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#render-reconciliation"}},[e._v("#")]),e._v(" render / reconciliation")]),e._v(" "),r("p",[e._v("根据fiber tree，把每个fiber作为一个工作单元。自顶向下每个节点构造"),r("code",[e._v("workInProgress tree")])]),e._v(" "),r("ol",[r("li",[e._v("当前节点是否需要更新？更新，打tag，到2 ： 不更新，clone子节点 ，到5")]),e._v(" "),r("li",[e._v("更新当前节点状态（props，state，context。。。）")]),e._v(" "),r("li",[e._v("调用"),r("code",[e._v("shouldComponentUpdate()")]),e._v(",false的话 到5")]),e._v(" "),r("li",[e._v("调用"),r("code",[e._v("render()")]),e._v("获得新的子节点，为子节点创建fiber，过程中尽量复用现有fiber，子节点也会在这里增删")]),e._v(" "),r("li",[e._v("如果没有child fiber，那么当前fiber工作结束，把"),r("code",[e._v("effect list")]),e._v("交给"),r("code",[e._v("return")]),e._v("，并把当前的节点的sibling作为下一个工作单元。有child的那么child作为下一个工作单元")]),e._v(" "),r("li",[e._v("如果剩余时间不足，那么等下一次主线程空闲了，再进行下一个fiber。否则立刻开始做")]),e._v(" "),r("li",[e._v("如果没有下一个fiber，那么第一阶段结束，进入"),r("code",[e._v("pendingCommit")]),e._v("状态")])]),e._v(" "),r("blockquote",[r("p",[e._v("1-6循环，7出口。循环过程，做完看要不要休息。")]),e._v(" "),r("p",[e._v("循环结束时，"),r("code",[e._v("workInProgress tree")]),e._v("的根节点上的effect list，就是收集到的所有effect（每次做完一个就向上归并）")])]),e._v(" "),r("blockquote",[r("p",[e._v("实际上，构建workInprogress的过程就是diff过程。通过"),r("code",[e._v("requestIdleCallback")]),e._v("来调度执行一组任务。")]),e._v(" "),r("p",[e._v("每次执行完看看有没有紧急任务，把控制权交给主线程，然后等待下一次的"),r("code",[e._v("requestIdleCallback")]),e._v("回调继续构建"),r("code",[e._v("workInProgress tree")])])]),e._v(" "),r("p",[r("code",[e._v("requestIdleCallback")])]),e._v(" "),r("h3",{attrs:{id:"commit"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#commit"}},[e._v("#")]),e._v(" commit")]),e._v(" "),r("ol",[r("li",[e._v("处理effect list，（更新DOM树、调用生命周期、更新ref内部状态）")]),e._v(" "),r("li",[e._v("结束，完成commit到DOM树")])]),e._v(" "),r("blockquote",[r("p",[e._v("这里是一口气做完。")]),e._v(" "),r("p",[e._v("建议不要再后3个生命周期做复杂工作")])]),e._v(" "),r("h2",{attrs:{id:"优先级策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优先级策略"}},[e._v("#")]),e._v(" 优先级策略")]),e._v(" "),r("p",[e._v("每个工作单元运行时有6种优先级：")]),e._v(" "),r("ul",[r("li",[e._v("synchronous 与之前的Stack reconciler操作一样，同步执行")]),e._v(" "),r("li",[e._v("task 在next tick之前执行")]),e._v(" "),r("li",[e._v("animation 下一帧之前执行")]),e._v(" "),r("li",[e._v("high 在不久的将来立即执行")]),e._v(" "),r("li",[e._v("low 稍微延迟（100-200ms）执行也没关系")]),e._v(" "),r("li",[e._v("offscreen 下一次render时或scroll时才执行")])])])}),[],!1,null,null,null);t.default=s.exports}}]);